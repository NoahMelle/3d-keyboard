/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { useRef } from "react";
import { ThreeEvent, useFrame } from "@react-three/fiber";
import { nanoid } from "nanoid";

type GLTFResult = GLTF & {
    nodes: {
        keyboardBase: THREE.Mesh;
        knob: THREE.Mesh;
        potMeters: THREE.Mesh;
        volumeKnob: THREE.Mesh;
        blackKey: THREE.Mesh;
        leftToBlackMesh: THREE.Mesh;
        leftToBlackMesh_1: THREE.Mesh;
        middleKeyMesh: THREE.Mesh;
        middleKeyMesh_1: THREE.Mesh;
        rightToBlackMesh: THREE.Mesh;
        rightToBlackMesh_1: THREE.Mesh;
        fullSizeKey: THREE.Mesh;
    };
    materials: {
        yellow: THREE.MeshStandardMaterial;
        shinyBlack: THREE.MeshStandardMaterial;
        shinyWhite: THREE.MeshStandardMaterial;
    };
};

export function Keyboard(props: JSX.IntrinsicElements["group"]) {
    const { nodes, materials } = useGLTF(
        "/assets/models/keyboard.glb"
    ) as GLTFResult;

    const allWhiteKeysLength = 0.713;

    const whiteKeyWidth = allWhiteKeysLength / 19;

    return (
        <group {...props} dispose={null}>
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.keyboardBase.geometry}
                material={materials.yellow}
                scale={[0.424, 0.033, 0.153]}
            />
            <group>
                <group>
                    {Array.from({ length: 4 }).map((_, i) => {
                        const xOffset = i * 0.04;

                        return Array.from({ length: 3 }).map((_, j) => {
                            const yOffset = j * 0.025;

                            return (
                                <mesh
                                    key={nanoid()}
                                    castShadow
                                    receiveShadow
                                    geometry={nodes.knob.geometry}
                                    material={materials.shinyBlack}
                                    position={[
                                        -0.345 + xOffset,
                                        0.033,
                                        -0.111 + yOffset,
                                    ]}
                                    scale={[0.014, 0.003, 0.007]}
                                />
                            );
                        });
                    })}
                </group>
                <group>
                    {Array.from({ length: 8 }).map((_, i) => {
                        const xOffset = i * 0.04;

                        return (
                            <mesh
                                key={nanoid()}
                                castShadow
                                receiveShadow
                                geometry={nodes.potMeters.geometry}
                                material={materials.shinyBlack}
                                position={[-0.162 + xOffset, 0.033, -0.086]}
                                scale={[0.01, 0.006, 0.01]}
                            />
                        );
                    })}
                </group>
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.volumeKnob.geometry}
                    material={materials.shinyBlack}
                    position={[0.33, 0.033, -0.086]}
                    scale={[0.018, 0.006, 0.018]}
                />
            </group>
            {Array.from({ length: 19 }, (_, i) => {
                const geometryIndex = i % 7;

                const middleKeys = [1, 2, 5];
                const leftToBlackKeys = [0, 4];
                const rightToBlackKeys = [3, 6];

                let geometry: THREE.BufferGeometry;

                if (i === 18) {
                    geometry = nodes.fullSizeKey.geometry;
                } else if (middleKeys.includes(geometryIndex)) {
                    geometry = nodes.middleKeyMesh.geometry;
                } else if (leftToBlackKeys.includes(geometryIndex)) {
                    geometry = nodes.leftToBlackMesh.geometry;
                } else if (rightToBlackKeys.includes(geometryIndex)) {
                    geometry = nodes.rightToBlackMesh.geometry;
                } else {
                    geometry = nodes.fullSizeKey.geometry;
                }

                const xPos =
                    i * whiteKeyWidth -
                    allWhiteKeysLength / 2 +
                    0.5 * whiteKeyWidth;

                const startingOctave = 4;
                const startingKey = 3;

                const fullKey = startingKey + i;

                const keyIdOctave = Math.floor(fullKey / 7) + startingOctave;
                const keyIdKey = indexToAlphabet(fullKey % 7);

                const keyId = `${keyIdKey}${keyIdOctave}`;

                return (
                    <WhiteKey
                        key={i}
                        noteId={keyId}
                        xPos={xPos}
                        geometry={geometry}
                        material={materials.shinyWhite}
                    />
                );
            })}
            {Array.from({ length: 17 }).map((_, i) => {
                const geometryIndex = i % 7;

                const blackKeys = [0, 1, 2, 4, 5];

                if (!blackKeys.includes(geometryIndex)) {
                    return null;
                }

                const startingOctave = 4;
                const startingKey = 3;

                const fullKey = i + startingKey;

                let keyIdOctave = Math.floor(fullKey / 7) + startingOctave;
                let keyIdKey = indexToAlphabet(fullKey % 7);

                let keyId = `${keyIdKey}-sharp${keyIdOctave}`;

                const xPos =
                    i * whiteKeyWidth -
                    (allWhiteKeysLength - whiteKeyWidth * 2) / 2;

                return (
                    <BlackKey
                        key={nanoid()}
                        geometry={nodes.blackKey.geometry}
                        material={materials.shinyBlack}
                        xPos={xPos}
                        noteId={keyId}
                    />
                );
            })}
        </group>
    );
}

useGLTF.preload("/assets/models/keyboard.glb");

const WhiteKey = ({
    geometry,
    material,
    xPos,
    noteId,
}: {
    geometry: THREE.BufferGeometry;
    material: THREE.Material;
    xPos: number;
    noteId: string;
}) => {
    return (
        <Key noteId={noteId}>
            <mesh
                castShadow
                receiveShadow
                geometry={geometry}
                material={material}
                position={[xPos, 0.008, 0.043]}
                rotation={[-Math.PI, 0, -Math.PI]}
                scale={[-0.328, -0.008, -0.09]}
            />
        </Key>
    );
};

const BlackKey = ({
    geometry,
    material,
    noteId,
    xPos,
}: {
    geometry: THREE.BufferGeometry;
    material: THREE.Material;
    noteId: string;
    xPos: number;
}) => {
    return (
        <Key noteId={noteId}>
            <mesh
                castShadow
                receiveShadow
                geometry={geometry}
                material={material}
                scale={[0.007, 0.015, 0.056]}
                position={[xPos, 0.014, 0.033]}
            />
        </Key>
    );
};

const Key = ({
    children,
    noteId,
}: {
    children: React.ReactNode;
    noteId?: string;
}) => {
    const lastPressed = useRef<number | null>(null);
    const keyRef = useRef<THREE.Group>(null!);
    const audioDuration = useRef<number>(0);

    const audioRef = useRef(new Audio(`/assets/audio/labs/labs_${noteId}.mp3`));
    audioRef.current.volume = 0.5;
    audioRef.current.onloadedmetadata = () => {
        audioDuration.current = audioRef.current.duration * 450;
    };

    const VISUAL_PRESS_DURATION = 200;

    const INTENSITY = -0.005;

    useFrame(() => {
        if (!lastPressed.current) return;

        // Time since key press
        const elapsed = Date.now() - lastPressed.current;

        // Progress of the press (0 - 1)
        const progress = Math.min(elapsed / VISUAL_PRESS_DURATION, 1);

        const offset = Math.sin(progress * Math.PI) * INTENSITY;
        keyRef.current.position.y = offset;

        // Press is over, user is allowed to press again
        if (Date.now() - lastPressed.current > audioDuration.current) {
            lastPressed.current = null;
        }
    });

    const handlePress = (event: ThreeEvent<PointerEvent>) => {
        if (lastPressed.current) return;

        if (event?.intersections[0].object !== event.object) return;

        audioRef.current.pause();
        audioRef.current.currentTime = 0;
        audioRef.current.play();

        lastPressed.current = Date.now();
    };

    return (
        <group ref={keyRef} onPointerDown={handlePress}>
            {children}
        </group>
    );
};

function indexToAlphabet(index: number) {
    const keysMap = new Map([
        [0, "c"],
        [1, "d"],
        [2, "e"],
        [3, "f"],
        [4, "g"],
        [5, "a"],
        [6, "b"],
    ]);

    return keysMap.get(index);
}
