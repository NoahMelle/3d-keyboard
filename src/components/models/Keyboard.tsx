/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from "three";
import React, { useRef } from "react";
import { useGLTF } from "@react-three/drei";
import { GLTF } from "three-stdlib";
import { nanoid } from "nanoid";
import { ThreeEvent, useFrame } from "@react-three/fiber";

type GLTFResult = GLTF & {
    nodes: {
        Cube: THREE.Mesh;
        Cylinder: THREE.Mesh;
        Cylinder001: THREE.Mesh;
        Cube003: THREE.Mesh;
        Black_Key001: THREE.Mesh;
        Black_Key002: THREE.Mesh;
        Black_Key003: THREE.Mesh;
        Black_Key004: THREE.Mesh;
        Black_Key005: THREE.Mesh;
        Black_Key006: THREE.Mesh;
        Black_Key007: THREE.Mesh;
        Black_Key008: THREE.Mesh;
        Black_Key009: THREE.Mesh;
        Black_Key010: THREE.Mesh;
        Black_Key011: THREE.Mesh;
        Black_Key012: THREE.Mesh;
        Black_Key013: THREE.Mesh;
        Cube004: THREE.Mesh;
        Cube004_1: THREE.Mesh;
        Cube033: THREE.Mesh;
        Cube033_1: THREE.Mesh;
        Cube034: THREE.Mesh;
        Cube034_1: THREE.Mesh;
        Cube035: THREE.Mesh;
        Cube035_1: THREE.Mesh;
        Cube036: THREE.Mesh;
        Cube036_1: THREE.Mesh;
        Cube037: THREE.Mesh;
        Cube037_1: THREE.Mesh;
        Cube038: THREE.Mesh;
        Cube038_1: THREE.Mesh;
        Cube039: THREE.Mesh;
        Cube039_1: THREE.Mesh;
        Cube040: THREE.Mesh;
        Cube040_1: THREE.Mesh;
        Cube041: THREE.Mesh;
        Cube041_1: THREE.Mesh;
        Cube042: THREE.Mesh;
        Cube042_1: THREE.Mesh;
        Cube043: THREE.Mesh;
        Cube043_1: THREE.Mesh;
        Cube044: THREE.Mesh;
        Cube044_1: THREE.Mesh;
        Cube045: THREE.Mesh;
        Cube045_1: THREE.Mesh;
        Cube046: THREE.Mesh;
        Cube046_1: THREE.Mesh;
        Cube047: THREE.Mesh;
        Cube047_1: THREE.Mesh;
        Cube048: THREE.Mesh;
        Cube048_1: THREE.Mesh;
        Cube049: THREE.Mesh;
        Cube049_1: THREE.Mesh;
        Keys018: THREE.Mesh;
    };
    materials: {
        ["Material.006"]: THREE.MeshStandardMaterial;
        ["Material.003"]: THREE.MeshStandardMaterial;
        ["Material.008"]: THREE.MeshStandardMaterial;
    };
};

export function Keyboard(props: JSX.IntrinsicElements["group"]) {
    const { nodes, materials } = useGLTF(
        "/assets/models/keyboard.glb"
    ) as GLTFResult;

    return (
        <group {...props} dispose={null}>
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube.geometry}
                material={materials["Material.006"]}
                scale={[0.424, 0.033, 0.153]}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder.geometry}
                material={materials["Material.003"]}
                position={[0.33, 0.033, -0.086]}
                scale={[0.018, 0.006, 0.018]}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cylinder001.geometry}
                material={materials["Material.003"]}
                position={[-0.162, 0.033, -0.086]}
                scale={[0.01, 0.006, 0.01]}
            />
            <mesh
                castShadow
                receiveShadow
                geometry={nodes.Cube003.geometry}
                material={materials["Material.003"]}
                position={[-0.345, 0.033, -0.111]}
                scale={[0.014, 0.003, 0.007]}
            />

            {/* Black Keys  */}
            {Array.from({ length: 13 }).map((_, index) => (
                <Key key={nanoid()}>
                    <BlackKey
                        geometry={
                            (nodes as any)[
                                `Black_Key${String(index + 1).padStart(3, "0")}`
                            ].geometry
                        }
                        material={materials["Material.003"]}
                    />
                </Key>
            ))}

            {[
                nodes.Cube004,
                nodes.Cube033,
                nodes.Cube034,
                nodes.Cube035,
                nodes.Cube036,
                nodes.Cube037,
                nodes.Cube038,
                nodes.Cube039,
                nodes.Cube040,
                nodes.Cube041,
                nodes.Cube042,
                nodes.Cube043,
                nodes.Cube044,
                nodes.Cube045,
                nodes.Cube046,
                nodes.Cube047,
                nodes.Cube048,
                nodes.Cube049,
            ].map((node) => (
                <Key key={nanoid()}>
                    <WhiteKey
                        material={materials["Material.008"]}
                        geometry={node.geometry}
                    />
                </Key>
            ))}

            <Key>
                <mesh
                    castShadow
                    receiveShadow
                    geometry={nodes.Keys018.geometry}
                    material={materials["Material.008"]}
                    position={[0, 0.008, 0.043]}
                    rotation={[-Math.PI, 0, -Math.PI]}
                    scale={[-0.328, -0.008, -0.09]}
                />
            </Key>
        </group>
    );
}

useGLTF.preload("/assets/models/keyboard.glb");

const WhiteKey = ({
    geometry,
    material,
}: {
    geometry: THREE.BufferGeometry;
    material: THREE.Material;
}) => {
    return (
        <group
            position={[0, 0.008, 0.043]}
            rotation={[-Math.PI, 0, -Math.PI]}
            scale={[-0.328, -0.008, -0.09]}
        >
            <mesh
                castShadow
                receiveShadow
                geometry={geometry}
                material={material}
            />
        </group>
    );
};

const BlackKey = ({ geometry, material }: any) => {
    return (
        <mesh
            castShadow
            receiveShadow
            geometry={geometry}
            material={material}
            position={[-0.283, 0.014, 0.024]}
            scale={[0.009, 0.015, 0.056]}
        />
    );
};

const Key = ({ children }: { children: React.ReactNode }) => {
    const lastPressed = useRef<number | null>(null);
    const keyRef = useRef<THREE.Group>(null!);

    const PRESS_DURATION = 200;
    const INTENSITY = -0.005;

    useFrame(() => {
        if (!lastPressed.current) return;

        // Time since key press
        const elapsed = Date.now() - lastPressed.current;

        // Progress of the press (0 - 1)
        const progress = Math.min(elapsed / PRESS_DURATION, 1);

        const offset = Math.sin(progress * Math.PI) * INTENSITY;
        keyRef.current.position.y = offset;

        // Press is over, user is allowed to press again
        if (Date.now() - lastPressed.current > PRESS_DURATION) {
            lastPressed.current = null;
        }
    });

    const handlePress = (event: ThreeEvent<PointerEvent>) => {
        if (lastPressed.current) return;

        // Don't trigger if the user is dragging the camera
        if (event?.intersections[0].object !== event.object) return;

        lastPressed.current = Date.now();
    };

    return (
        <group ref={keyRef} onPointerDown={handlePress}>
            {children}
        </group>
    );
};
