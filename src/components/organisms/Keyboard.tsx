/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from "@react-three/drei";
import { ThreeEvent, useFrame } from "@react-three/fiber";
import { useCallback, useEffect, useRef } from "react";
import * as THREE from "three";
import { GLTF } from "three-stdlib";

import VolumeKnob from "@/components/atoms/VolumeKnob";
import KeyboardButtons from "@/components/molecules/KeyboardButtons";
import KeyboardKnobs from "@/components/molecules/KeyboardKnobs";
import { useKeyboardLayout } from "@/hooks/useKeyboardLayout";
import useMidi from "@/hooks/useMidi";
import useSynthesizer from "@/hooks/useSynthesizer";
import { getGeometryByType } from "@/utils/getGeometryByType";

export type GLTFResult = GLTF & {
  nodes: {
    keyboardBase: THREE.Mesh;
    knob: THREE.Mesh;
    potMeters: THREE.Mesh;
    volumeKnob: THREE.Mesh;
    blackKey: THREE.Mesh;
    leftToBlackMesh: THREE.Mesh;
    leftToBlackMesh_1: THREE.Mesh;
    middleKeyMesh: THREE.Mesh;
    middleKeyMesh_1: THREE.Mesh;
    rightToBlackMesh: THREE.Mesh;
    rightToBlackMesh_1: THREE.Mesh;
    fullSizeKey: THREE.Mesh;
  };
  materials: {
    yellow: THREE.MeshStandardMaterial;
    shinyBlack: THREE.MeshStandardMaterial;
    shinyWhite: THREE.MeshStandardMaterial;
  };
};

export function Keyboard(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/assets/models/keyboard.glb"
  ) as GLTFResult;

  const allWhiteKeysLength = 0.713;
  const whiteKeyWidth = allWhiteKeysLength / 19;

  const { blackKeys, whiteKeys } = useKeyboardLayout(
    whiteKeyWidth,
    allWhiteKeysLength,
    {
      startingNote: 60,
    }
  );

  return (
    <group {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.keyboardBase.geometry}
        material={materials.yellow}
        scale={[0.424, 0.033, 0.153]}
      />

      <group>
        <KeyboardButtons
          geometry={nodes.knob.geometry}
          material={materials.shinyBlack}
        />

        <KeyboardKnobs
          geometry={nodes.potMeters.geometry}
          material={materials.shinyBlack}
        />

        <VolumeKnob
          geometry={nodes.volumeKnob.geometry}
          material={materials.shinyBlack}
        />
      </group>

      {whiteKeys.map((key) => (
        <WhiteKey
          key={key.id}
          noteId={key.id}
          xPos={key.xPos}
          geometry={getGeometryByType(key.geometryType, nodes)}
          material={materials.shinyWhite}
        />
      ))}

      {blackKeys.map((key) => (
        <BlackKey
          geometry={nodes.blackKey.geometry}
          material={materials.shinyBlack}
          noteId={key.id}
          xPos={key.xPos}
          key={key.id}
        />
      ))}
    </group>
  );
}

useGLTF.preload("/assets/models/keyboard.glb");

const WhiteKey = ({
  geometry,
  material,
  xPos,
  noteId,
}: {
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  xPos: number;
  noteId: number;
}) => {
  return (
    <Key noteId={noteId}>
      <mesh
        castShadow
        receiveShadow
        geometry={geometry}
        material={material}
        position={[xPos, 0.008, 0.043]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.328, -0.008, -0.09]}
      />
    </Key>
  );
};

const BlackKey = ({
  geometry,
  material,
  noteId,
  xPos,
}: {
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  noteId: number;
  xPos: number;
}) => {
  return (
    <Key noteId={noteId}>
      <mesh
        castShadow
        receiveShadow
        geometry={geometry}
        material={material}
        scale={[0.007, 0.015, 0.056]}
        position={[xPos, 0.014, 0.033]}
      />
    </Key>
  );
};

const Key = ({
  children,
  noteId,
}: {
  children: React.ReactNode;
  noteId?: number;
}) => {
  const lastPressed = useRef<number | null>(null);
  const keyRef = useRef<THREE.Group>(null!);
  const isPressedRef = useRef<boolean>(false);
  const { registerKeyPress } = useMidi();
  const { triggerNote, releaseNote } = useSynthesizer();

  const VISUAL_PRESS_DURATION = 200;
  const INTENSITY = -0.005;

  useFrame(() => {
    if (!lastPressed.current) {
      // Reset position when not pressed
      if (keyRef.current.position.y !== 0) {
        keyRef.current.position.y = 0;
      }
      return;
    }

    // Time since key press
    const elapsed = Date.now() - lastPressed.current;

    // Progress of the press (0 - 1)
    const progress = Math.min(elapsed / VISUAL_PRESS_DURATION, 1);

    const offset = Math.sin(progress * Math.PI) * INTENSITY;
    keyRef.current.position.y = offset;

    // Reset after visual animation
    if (elapsed > VISUAL_PRESS_DURATION && !isPressedRef.current) {
      lastPressed.current = null;
    }
  });

  const handleKeyPress = useCallback(
    (velocity: number = 0.8) => {
      if (noteId === undefined) return;
      if (isPressedRef.current) return;

      isPressedRef.current = true;
      lastPressed.current = Date.now();
      triggerNote(noteId, velocity);
    },
    [noteId, triggerNote]
  );

  const handleKeyRelease = useCallback(() => {
    if (noteId === undefined) return;
    if (!isPressedRef.current) return;

    isPressedRef.current = false;
    releaseNote(noteId);

    // Allow visual animation to complete
    setTimeout(() => {
      if (!isPressedRef.current) {
        lastPressed.current = null;
      }
    }, VISUAL_PRESS_DURATION);
  }, [noteId, releaseNote]);

  // Register this key with MIDI context
  useEffect(() => {
    if (noteId === undefined) return;

    const unregister = registerKeyPress(
      noteId,
      () => handleKeyPress(0.8),
      handleKeyRelease
    );
    return unregister;
  }, [noteId, registerKeyPress, handleKeyPress, handleKeyRelease]);

  const handlePress = (event: ThreeEvent<PointerEvent>) => {
    if (event?.intersections[0].object !== event.object) return;

    handleKeyPress(0.8);
  };

  const handleRelease = () => {
    handleKeyRelease();
  };

  return (
    <group
      ref={keyRef}
      onPointerDown={handlePress}
      onPointerUp={handleRelease}
      onPointerLeave={handleRelease}
    >
      {children}
    </group>
  );
};
