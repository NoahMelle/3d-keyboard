/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import { useGLTF } from "@react-three/drei";
import { ThreeEvent, useFrame } from "@react-three/fiber";
import { useRef } from "react";
import * as THREE from "three";
import { GLTF } from "three-stdlib";

import VolumeKnob from "@/components/atoms/VolumeKnob";
import KeyboardButtons from "@/components/molecules/KeyboardButtons";
import KeyboardKnobs from "@/components/molecules/KeyboardKnobs";
import { useKeyboardLayout } from "@/hooks/useKeyboardLayout";
import { getGeometryByType } from "@/utils/getGeometryByType";

export type GLTFResult = GLTF & {
  nodes: {
    keyboardBase: THREE.Mesh;
    knob: THREE.Mesh;
    potMeters: THREE.Mesh;
    volumeKnob: THREE.Mesh;
    blackKey: THREE.Mesh;
    leftToBlackMesh: THREE.Mesh;
    leftToBlackMesh_1: THREE.Mesh;
    middleKeyMesh: THREE.Mesh;
    middleKeyMesh_1: THREE.Mesh;
    rightToBlackMesh: THREE.Mesh;
    rightToBlackMesh_1: THREE.Mesh;
    fullSizeKey: THREE.Mesh;
  };
  materials: {
    yellow: THREE.MeshStandardMaterial;
    shinyBlack: THREE.MeshStandardMaterial;
    shinyWhite: THREE.MeshStandardMaterial;
  };
};

export function Keyboard(props: JSX.IntrinsicElements["group"]) {
  const { nodes, materials } = useGLTF(
    "/assets/models/keyboard.glb"
  ) as GLTFResult;

  const allWhiteKeysLength = 0.713;
  const whiteKeyWidth = allWhiteKeysLength / 19;

  const { blackKeys, whiteKeys } = useKeyboardLayout(
    whiteKeyWidth,
    allWhiteKeysLength
  );

  return (
    <group {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.keyboardBase.geometry}
        material={materials.yellow}
        scale={[0.424, 0.033, 0.153]}
      />

      <group>
        <KeyboardButtons
          geometry={nodes.knob.geometry}
          material={materials.shinyBlack}
        />

        <KeyboardKnobs
          geometry={nodes.potMeters.geometry}
          material={materials.shinyBlack}
        />

        <VolumeKnob
          geometry={nodes.volumeKnob.geometry}
          material={materials.shinyBlack}
        />
      </group>

      {whiteKeys.map((key) => (
        <WhiteKey
          key={key.id}
          noteId={key.id}
          xPos={key.xPos}
          geometry={getGeometryByType(key.geometryType, nodes)}
          material={materials.shinyWhite}
        />
      ))}

      {blackKeys.map((key) => (
        <BlackKey
          geometry={nodes.blackKey.geometry}
          material={materials.shinyBlack}
          noteId={key.id}
          xPos={key.xPos}
          key={key.id}
        />
      ))}
    </group>
  );
}

useGLTF.preload("/assets/models/keyboard.glb");

const WhiteKey = ({
  geometry,
  material,
  xPos,
  noteId,
}: {
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  xPos: number;
  noteId: string;
}) => {
  return (
    <Key noteId={noteId}>
      <mesh
        castShadow
        receiveShadow
        geometry={geometry}
        material={material}
        position={[xPos, 0.008, 0.043]}
        rotation={[-Math.PI, 0, -Math.PI]}
        scale={[-0.328, -0.008, -0.09]}
      />
    </Key>
  );
};

const BlackKey = ({
  geometry,
  material,
  noteId,
  xPos,
}: {
  geometry: THREE.BufferGeometry;
  material: THREE.Material;
  noteId: string;
  xPos: number;
}) => {
  return (
    <Key noteId={noteId}>
      <mesh
        castShadow
        receiveShadow
        geometry={geometry}
        material={material}
        scale={[0.007, 0.015, 0.056]}
        position={[xPos, 0.014, 0.033]}
      />
    </Key>
  );
};

const Key = ({
  children,
  noteId,
}: {
  children: React.ReactNode;
  noteId?: string;
}) => {
  const lastPressed = useRef<number | null>(null);
  const keyRef = useRef<THREE.Group>(null!);
  const audioDuration = useRef<number>(0);

  const audioRef = useRef(new Audio(`/assets/audio/labs/labs_${noteId}.mp3`));
  audioRef.current.volume = 0.5;
  audioRef.current.onloadedmetadata = () => {
    audioDuration.current = audioRef.current.duration * 450;
  };

  const VISUAL_PRESS_DURATION = 200;

  const INTENSITY = -0.005;

  useFrame(() => {
    if (!lastPressed.current) return;

    // Time since key press
    const elapsed = Date.now() - lastPressed.current;

    // Progress of the press (0 - 1)
    const progress = Math.min(elapsed / VISUAL_PRESS_DURATION, 1);

    const offset = Math.sin(progress * Math.PI) * INTENSITY;
    keyRef.current.position.y = offset;

    // Press is over, user is allowed to press again
    if (Date.now() - lastPressed.current > audioDuration.current) {
      lastPressed.current = null;
    }
  });

  const handlePress = (event: ThreeEvent<PointerEvent>) => {
    if (lastPressed.current) return;

    if (event?.intersections[0].object !== event.object) return;

    audioRef.current.pause();
    audioRef.current.currentTime = 0;
    audioRef.current.play();

    lastPressed.current = Date.now();
  };

  return (
    <group ref={keyRef} onPointerDown={handlePress}>
      {children}
    </group>
  );
};
